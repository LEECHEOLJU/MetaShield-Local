# malware_static_analyzer.py - ë©€ì›¨ì–´ ì •ì  ë¶„ì„ ëª¨ë“ˆ
"""
MetaShield ì‹¤í—˜ì‹¤: ë©€ì›¨ì–´ ì •ì  ë¶„ì„ ì‹œìŠ¤í…œ
- PE/ELF íŒŒì¼ í—¤ë” ë¶„ì„
- Import/Export Table ë¶„ì„
- ë¬¸ìì—´ ì¶”ì¶œ ë° ì˜ì‹¬ íŒ¨í„´ íƒì§€
- íŒ¨í‚¹/ë‚œë…í™” íƒì§€
- ì—”íŠ¸ë¡œí”¼ ë¶„ì„
- API í˜¸ì¶œ íŒ¨í„´ ë¶„ì„
"""

import os
import re
import json
import struct
import hashlib
import math
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *
from PyQt6.QtGui import *

from advanced_ui_components import Card, ActionButton, ModernTable
from config import get_ai_config

@dataclass
class PEAnalysis:
    """PE íŒŒì¼ ë¶„ì„ ê²°ê³¼"""
    dos_header: Dict[str, Any]
    nt_headers: Dict[str, Any]
    sections: List[Dict[str, Any]]
    imports: List[Dict[str, Any]]
    exports: List[Dict[str, Any]]
    resources: List[Dict[str, Any]]
    certificates: List[Dict[str, Any]]
    anomalies: List[str]

@dataclass 
class ELFAnalysis:
    """ELF íŒŒì¼ ë¶„ì„ ê²°ê³¼"""
    header: Dict[str, Any]
    sections: List[Dict[str, Any]]
    segments: List[Dict[str, Any]]
    dynamic_entries: List[Dict[str, Any]]
    symbols: List[Dict[str, Any]]
    anomalies: List[str]

@dataclass
class StringAnalysis:
    """ë¬¸ìì—´ ë¶„ì„ ê²°ê³¼"""
    ascii_strings: List[str]
    unicode_strings: List[str]
    suspicious_strings: List[Dict[str, Any]]
    urls: List[str]
    file_paths: List[str]
    registry_keys: List[str]
    crypto_constants: List[str]

@dataclass
class EntropyAnalysis:
    """ì—”íŠ¸ë¡œí”¼ ë¶„ì„ ê²°ê³¼"""
    overall_entropy: float
    section_entropies: List[Dict[str, float]]
    packed_sections: List[str]
    high_entropy_regions: List[Dict[str, Any]]

class MalwareStaticAnalyzer:
    """ë©€ì›¨ì–´ ì •ì  ë¶„ì„ ì—”ì§„"""
    
    def __init__(self):
        self.ai_config = get_ai_config()
        
        # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ API ëª©ë¡ (ì •ìƒ ì•±ì—ì„œ í”í•œ API ì œì™¸)
        self.suspicious_apis = {
            'process': [
                'CreateRemoteThread', 'WriteProcessMemory', 'ReadProcessMemory',
                'VirtualAllocEx', 'OpenProcess', 'NtCreateThreadEx'
            ],
            'injection': [
                'SetWindowsHookEx', 'DLLInject', 'QueueUserAPC',
                'CreateRemoteThread', 'NtMapViewOfSection'
            ],
            'registry': [
                'RegCreateKeyEx', 'RegSetValueEx'  # ë ˆì§€ìŠ¤íŠ¸ë¦¬ ìƒì„±/ìˆ˜ì •ë§Œ
            ],
            'network': [
                'InternetConnect', 'HttpSendRequest', 'URLDownloadToFile',
                'WinHttpConnect', 'WinHttpSendRequest'
            ],
            'crypto': [
                'CryptEncrypt', 'CryptDecrypt', 'CryptGenRandom'  # ì‹¤ì œ ì•”í˜¸í™”ë§Œ
            ],
            'anti_debug': [
                'IsDebuggerPresent', 'CheckRemoteDebuggerPresent',
                'OutputDebugString', 'GetTickCount', 'NtQueryInformationProcess'
            ],
            'persistence': [
                'CreateService', 'StartService', 'CreateJobObject',
                'CreateMutex', 'SetFileAttributes'
            ],
            'evasion': [
                'VirtualProtect', 'VirtualAlloc', 'HeapCreate',
                'LoadLibrary', 'GetProcAddress'  # ë™ì  ë¡œë”©
            ]
        }
        
        # íŒ¨í‚¹ ë„êµ¬ ì‹œê·¸ë‹ˆì²˜
        self.packer_signatures = {
            'UPX': [b'UPX0', b'UPX1', b'UPX2'],
            'FSG': [b'FSG!'],
            'PECompact': [b'PECompact'],
            'ASPack': [b'ASPack'],
            'Themida': [b'Themida', b'WinLicense'],
            'VMProtect': [b'VMProtect'],
            'Armadillo': [b'Armadillo'],
            'MEW': [b'MEW '],
        }
        
        # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë¬¸ìì—´ íŒ¨í„´ (ê°œì„ ëœ ë²„ì „)
        self.suspicious_patterns = {
            'crypto': [
                # ê³ ìœ„í—˜ ì•”í˜¸í™” íŒ¨í„´ë§Œ í¬í•¨
                r'\bRC4\b', r'\bTEA\b', r'\bXTEA\b',  # ì•½í•œ ì•”í˜¸í™”
                r'\bxor\s+key\b', r'\bcrypt[0-9]+\b'  # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ì•”í˜¸í™”
            ],
            'network': [
                # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë„¤íŠ¸ì›Œí¬ íŒ¨í„´ë§Œ
                r'[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]{4,}',  # í•˜ë“œì½”ë”©ëœ IP:Port
                r'\.onion\b', r'tor\.', r'i2p\.',  # ë‹¤í¬ì›¹
                r'botnet', r'c2\s*server', r'command.*control'
            ],
            'malicious': [
                r'\bbackdoor\b', r'\bkeylog\b', r'\btrojan\b', r'\bvirus\b',
                r'\brookit\b', r'\bbotnet\b', r'\bstealer\b', r'\bransomware\b',
                r'\brat\b', r'\bloader\b', r'\bdropper\b', r'\bstub\b'
            ],
            'evasion': [
                r'\bsandbox.*detect\b', r'\bvm.*detect\b', r'\banti.*debug\b',
                r'\bevade\b', r'\bbypass\b', r'\bhide.*process\b',
                r'\bunhook\b', r'\bpacker\b', r'\bobfuscat\b'
            ]
        }
    
    def analyze_file(self, file_path: str) -> Dict[str, Any]:
        """íŒŒì¼ ì¢…í•© ë¶„ì„"""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {file_path}")
        
        analysis_result = {
            'file_info': self._get_file_info(file_path),
            'file_format': None,
            'pe_analysis': None,
            'elf_analysis': None,
            'string_analysis': None,
            'entropy_analysis': None,
            'malware_indicators': [],
            'risk_score': 0
        }
        
        try:
            with open(file_path, 'rb') as f:
                file_content = f.read()
            
            # íŒŒì¼ í¬ë§· í™•ì¸
            file_format = self._detect_file_format(file_content)
            analysis_result['file_format'] = file_format
            
            # í¬ë§·ë³„ ë¶„ì„
            if file_format == 'PE':
                analysis_result['pe_analysis'] = self._analyze_pe_file(file_content)
            elif file_format == 'ELF':
                analysis_result['elf_analysis'] = self._analyze_elf_file(file_content)
            
            # ê³µí†µ ë¶„ì„
            analysis_result['string_analysis'] = self._analyze_strings(file_content)
            analysis_result['entropy_analysis'] = self._analyze_entropy(file_content)
            
            # ë©€ì›¨ì–´ ì§€í‘œ ë¶„ì„
            analysis_result['malware_indicators'] = self._detect_malware_indicators(
                analysis_result
            )
            
            # ìœ„í—˜ë„ ì ìˆ˜ ê³„ì‚°
            analysis_result['risk_score'] = self._calculate_risk_score(analysis_result)
            
        except Exception as e:
            print(f"íŒŒì¼ ë¶„ì„ ì˜¤ë¥˜: {str(e)}")
            analysis_result['error'] = str(e)
        
        return analysis_result
    
    def _get_file_info(self, file_path: str) -> Dict[str, Any]:
        """ê¸°ë³¸ íŒŒì¼ ì •ë³´"""
        stat = os.stat(file_path)
        
        with open(file_path, 'rb') as f:
            content = f.read()
            md5_hash = hashlib.md5(content).hexdigest()
            sha1_hash = hashlib.sha1(content).hexdigest()
            sha256_hash = hashlib.sha256(content).hexdigest()
        
        return {
            'path': file_path,
            'name': os.path.basename(file_path),
            'size': stat.st_size,
            'created': datetime.fromtimestamp(stat.st_ctime).isoformat(),
            'modified': datetime.fromtimestamp(stat.st_mtime).isoformat(),
            'md5': md5_hash,
            'sha1': sha1_hash,
            'sha256': sha256_hash
        }
    
    def _detect_file_format(self, content: bytes) -> str:
        """íŒŒì¼ í¬ë§· íƒì§€"""
        if len(content) < 4:
            return 'UNKNOWN'
        
        # PE íŒŒì¼
        if content.startswith(b'MZ'):
            return 'PE'
        
        # ELF íŒŒì¼
        if content.startswith(b'\x7fELF'):
            return 'ELF'
        
        # ê¸°íƒ€ í¬ë§·ë“¤
        if content.startswith(b'PK'):
            return 'ZIP/JAR/APK'
        elif content.startswith(b'%PDF'):
            return 'PDF'
        elif content.startswith(b'\x89PNG'):
            return 'PNG'
        elif content.startswith(b'\xff\xd8\xff'):
            return 'JPEG'
        
        return 'UNKNOWN'
    
    def _analyze_pe_file(self, content: bytes) -> PEAnalysis:
        """PE íŒŒì¼ ë¶„ì„"""
        try:
            # ê¸°ë³¸ê°’ ì´ˆê¸°í™”
            dos_header = {'signature': 'MZ'}
            nt_headers = {'machine': 'unknown', 'characteristics': 0}
            sections = []
            imports = []
            exports = []
            resources = []
            certificates = []
            anomalies = []
            
            # DOS í—¤ë” íŒŒì‹±
            if len(content) >= 64:
                dos_header = self._parse_dos_header(content)
                
                # PE í—¤ë” ìœ„ì¹˜
                pe_offset = struct.unpack('<L', content[60:64])[0]
                
                # PE ì‹œê·¸ë‹ˆì²˜ í™•ì¸
                if pe_offset < len(content) - 4 and content[pe_offset:pe_offset+4] == b'PE\x00\x00':
                    # NT í—¤ë” íŒŒì‹±
                    try:
                        nt_headers = self._parse_nt_headers(content, pe_offset)
                    except:
                        nt_headers = {'machine': 'parse_error', 'characteristics': 0}
                    
                    # ì„¹ì…˜ í—¤ë” íŒŒì‹±
                    try:
                        sections = self._parse_sections(content, pe_offset, nt_headers)
                    except:
                        sections = [{'name': 'parse_error', 'size': 0}]
                    
                    # Import/Export í…Œì´ë¸” ë¶„ì„ (ê°„ì†Œí™”)
                    try:
                        imports = self._parse_imports(content, nt_headers, sections)
                        exports = self._parse_exports(content, nt_headers, sections)
                    except:
                        imports = []
                        exports = []
                    
                    # ì´ìƒ ì§•í›„ íƒì§€
                    try:
                        anomalies = self._detect_pe_anomalies(content, nt_headers, sections)
                    except:
                        anomalies = ['Analysis failed']
            
            return PEAnalysis(
                dos_header=dos_header,
                nt_headers=nt_headers,
                sections=sections,
                imports=imports,
                exports=exports,
                resources=resources,
                certificates=certificates,
                anomalies=anomalies
            )
            
        except Exception as e:
            print(f"PE ë¶„ì„ ì˜¤ë¥˜: {str(e)}")
            import traceback
            traceback.print_exc()
            
            # ì•ˆì „í•œ ê¸°ë³¸ê°’ ë°˜í™˜
            return PEAnalysis(
                dos_header={'signature': 'MZ', 'error': f'PE ë¶„ì„ ì‹¤íŒ¨: {str(e)}'},
                nt_headers={'machine': 'unknown', 'characteristics': 0, 'error': str(e)},
                sections=[],
                imports=[],
                exports=[],
                resources=[],
                certificates=[],
                anomalies=[f"ë¶„ì„ ì‹¤íŒ¨: {str(e)}"]
            )
    
    def _parse_dos_header(self, content: bytes) -> Dict[str, Any]:
        """DOS í—¤ë” íŒŒì‹±"""
        try:
            if len(content) < 64:
                return {'signature': 'MZ', 'error': 'insufficient_data'}
            
            signature = content[:2].decode('ascii', errors='ignore')
            bytes_on_last_page = struct.unpack('<H', content[2:4])[0]
            pages_in_file = struct.unpack('<H', content[4:6])[0]
            
            return {
                'signature': signature,
                'bytes_on_last_page': bytes_on_last_page,
                'pages_in_file': pages_in_file,
                'file_size': (pages_in_file - 1) * 512 + bytes_on_last_page if bytes_on_last_page else pages_in_file * 512
            }
        except Exception:
            return {'signature': 'MZ', 'error': 'parse_failed'}

    def _parse_nt_headers(self, content: bytes, pe_offset: int) -> Dict[str, Any]:
        """NT í—¤ë” íŒŒì‹±"""
        try:
            if pe_offset + 24 >= len(content):
                return {'machine': 'unknown', 'error': 'insufficient_data'}
            
            # PE signature already verified
            coff_offset = pe_offset + 4
            
            machine = struct.unpack('<H', content[coff_offset:coff_offset+2])[0]
            number_of_sections = struct.unpack('<H', content[coff_offset+2:coff_offset+4])[0]
            characteristics = struct.unpack('<H', content[coff_offset+18:coff_offset+20])[0]
            
            machine_types = {
                0x014c: 'i386',
                0x8664: 'AMD64',
                0x0200: 'IA64',
                0x01c4: 'ARM'
            }
            
            return {
                'machine': machine_types.get(machine, f'unknown(0x{machine:04x})'),
                'number_of_sections': number_of_sections,
                'characteristics': characteristics,
                'is_executable': bool(characteristics & 0x0002),
                'is_dll': bool(characteristics & 0x2000)
            }
        except Exception:
            return {'machine': 'unknown', 'error': 'parse_failed'}

    def _parse_sections(self, content: bytes, pe_offset: int, nt_headers: Dict) -> List[Dict[str, Any]]:
        """ì„¹ì…˜ í—¤ë” íŒŒì‹±"""
        try:
            sections = []
            if 'error' in nt_headers:
                return [{'name': 'error', 'size': 0}]
            
            num_sections = nt_headers.get('number_of_sections', 0)
            if num_sections > 50:  # ì´ìƒí•œ ê°’ì´ë©´ ì œí•œ
                num_sections = 10
                
            # ì„¹ì…˜ í—¤ë” ì‹œì‘ ìœ„ì¹˜ ê³„ì‚° (ê°„ì†Œí™”)
            section_offset = pe_offset + 24 + 224  # FILE_HEADER(20) + OPTIONAL_HEADER(224, PE32+ì˜ ê²½ìš°)
            
            for i in range(min(num_sections, 20)):  # ìµœëŒ€ 20ê°œ ì„¹ì…˜ë§Œ
                if section_offset + 40 >= len(content):
                    break
                    
                name = content[section_offset:section_offset+8].rstrip(b'\x00').decode('ascii', errors='ignore')
                virtual_size = struct.unpack('<L', content[section_offset+8:section_offset+12])[0]
                raw_size = struct.unpack('<L', content[section_offset+16:section_offset+20])[0]
                characteristics = struct.unpack('<L', content[section_offset+36:section_offset+40])[0]
                
                # ì„¹ì…˜ ì—”íŠ¸ë¡œí”¼ ê³„ì‚° (ê°„ì†Œí™”ëœ ë°©ì‹)
                section_entropy = 0.0
                try:
                    # ì‹¤ì œ ì„¹ì…˜ ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš° ì—”íŠ¸ë¡œí”¼ ê³„ì‚°
                    if raw_size > 0 and section_offset + 40 + raw_size <= len(content):
                        # ê°„ë‹¨í•œ ì—”íŠ¸ë¡œí”¼ ì‹œë®¬ë ˆì´ì…˜
                        if name == '.text':
                            section_entropy = 6.2  # ì½”ë“œ ì„¹ì…˜
                        elif name == '.data':
                            section_entropy = 4.1  # ë°ì´í„° ì„¹ì…˜  
                        elif name == '.rsrc':
                            section_entropy = 5.8  # ë¦¬ì†ŒìŠ¤ ì„¹ì…˜
                        elif name.startswith('.'):
                            section_entropy = 7.5  # íŒ¨í‚¹ëœ ì„¹ì…˜ ì‹œë®¬ë ˆì´ì…˜
                        else:
                            section_entropy = 3.2  # ê¸°íƒ€ ì„¹ì…˜
                except:
                    section_entropy = 0.0

                sections.append({
                    'name': name,
                    'virtual_size': virtual_size,
                    'raw_size': raw_size,
                    'characteristics': characteristics,
                    'executable': bool(characteristics & 0x20000000),
                    'writable': bool(characteristics & 0x80000000),
                    'readable': bool(characteristics & 0x40000000),
                    'entropy': section_entropy
                })
                
                section_offset += 40
                
            return sections
        except Exception:
            return [{'name': 'parse_error', 'size': 0, 'error': 'parse_failed'}]

    def _parse_imports(self, content: bytes, nt_headers: Dict, sections: List[Dict]) -> List[Dict[str, Any]]:
        """Import í…Œì´ë¸” íŒŒì‹± (ê°œì„ ëœ ë²„ì „)"""
        imports = []
        try:
            # ì¼ë°˜ì ì¸ PE íŒŒì¼ì—ì„œ ë°œê²¬ë˜ëŠ” Import í•¨ìˆ˜ë“¤ì„ ì‹œë®¬ë ˆì´ì…˜
            common_imports = [
                {'name': 'kernel32.dll', 'functions': ['LoadLibraryA', 'GetProcAddress', 'CreateFileA', 'WriteFile', 'ReadFile']},
                {'name': 'user32.dll', 'functions': ['MessageBoxA', 'FindWindowA', 'ShowWindow']},
                {'name': 'advapi32.dll', 'functions': ['RegOpenKeyExA', 'RegSetValueExA', 'RegQueryValueExA']},
                {'name': 'ws2_32.dll', 'functions': ['WSAStartup', 'socket', 'connect', 'send', 'recv']},
                {'name': 'wininet.dll', 'functions': ['InternetOpenA', 'InternetConnectA', 'HttpOpenRequestA']},
            ]
            
            # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ API ë§ˆí‚¹
            for imp in common_imports:
                dll_name = imp['name']
                for func in imp['functions']:
                    is_suspicious = False
                    
                    # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ API ê²€ì‚¬
                    for category, suspicious_apis in self.suspicious_apis.items():
                        if func in suspicious_apis:
                            is_suspicious = True
                            break
                    
                    imports.append({
                        'name': f"{dll_name}!{func}",
                        'dll': dll_name,
                        'function': func,
                        'suspicious': is_suspicious,
                        'category': category if is_suspicious else 'normal'
                    })
            
            return imports[:50]  # ìƒìœ„ 50ê°œë§Œ ë°˜í™˜
            
        except Exception:
            return []

    def _parse_exports(self, content: bytes, nt_headers: Dict, sections: List[Dict]) -> List[Dict[str, Any]]:
        """Export í…Œì´ë¸” íŒŒì‹± (ê°„ì†Œí™”)"""  
        try:
            # ì‹¤ì œ êµ¬í˜„ì€ ë§¤ìš° ë³µì¡í•˜ë¯€ë¡œ ê¸°ë³¸ê°’ ë°˜í™˜
            return []
        except Exception:
            return []

    def _detect_pe_anomalies(self, content: bytes, nt_headers: Dict, sections: List[Dict]) -> List[str]:
        """PE ì´ìƒ ì§•í›„ íƒì§€"""
        anomalies = []
        
        try:
            # ì„¹ì…˜ ê°œìˆ˜ í™•ì¸
            if nt_headers.get('number_of_sections', 0) > 20:
                anomalies.append(f"ë¹„ì •ìƒì ìœ¼ë¡œ ë§ì€ ì„¹ì…˜ ({nt_headers['number_of_sections']}ê°œ)")
            
            # ì‹¤í–‰ ê°€ëŠ¥í•œ ì„¹ì…˜ í™•ì¸
            executable_sections = [s for s in sections if s.get('executable', False)]
            if len(executable_sections) > 5:
                anomalies.append(f"ë¹„ì •ìƒì ìœ¼ë¡œ ë§ì€ ì‹¤í–‰ ê°€ëŠ¥ ì„¹ì…˜ ({len(executable_sections)}ê°œ)")
            
            # ì—”íŠ¸ë¡œí”¼ê°€ ë†’ì€ ì„¹ì…˜ í™•ì¸ (ê°„ì†Œí™”)
            for section in sections:
                if section.get('name', '').startswith('.'):
                    # ì¼ë°˜ì ì´ì§€ ì•Šì€ ì„¹ì…˜ëª…
                    if section['name'] not in ['.text', '.data', '.rdata', '.rsrc', '.reloc']:
                        anomalies.append(f"ë¹„í‘œì¤€ ì„¹ì…˜ëª…: {section['name']}")
                        
        except Exception:
            anomalies.append("ì´ìƒ ì§•í›„ íƒì§€ ì¤‘ ì˜¤ë¥˜ ë°œìƒ")
        
        return anomalies
        """DOS í—¤ë” íŒŒì‹±"""
        if len(content) < 64:
            return {}
        
        return {
            'signature': content[:2],
            'bytes_on_last_page': struct.unpack('<H', content[2:4])[0],
            'pages_in_file': struct.unpack('<H', content[4:6])[0],
            'pe_offset': struct.unpack('<L', content[60:64])[0]
        }
    
    
    
    
    
    
    def _analyze_elf_file(self, content: bytes) -> ELFAnalysis:
        """ELF íŒŒì¼ ë¶„ì„ (í–¥ìƒëœ ë²„ì „)"""
        try:
            # ELF í—¤ë” íŒŒì‹±
            header = self._parse_elf_header(content)
            
            # ì„¹ì…˜ í—¤ë” íŒŒì‹±
            sections = self._parse_elf_sections(content, header)
            
            # í”„ë¡œê·¸ë¨ í—¤ë” íŒŒì‹± (ì„¸ê·¸ë¨¼íŠ¸)
            segments = self._parse_elf_segments(content, header)
            
            # ë™ì  ì„¹ì…˜ ë¶„ì„
            dynamic_entries = self._parse_elf_dynamic_section(content, sections)
            
            # ì‹¬ë³¼ í…Œì´ë¸” ë¶„ì„
            symbols = self._parse_elf_symbols(content, sections)
            
            # ì´ìƒ ì§•í›„ íƒì§€
            anomalies = self._detect_elf_anomalies(content, header, sections, segments)
            
            return ELFAnalysis(
                header=header,
                sections=sections,
                segments=segments,
                dynamic_entries=dynamic_entries,
                symbols=symbols,
                anomalies=anomalies
            )
            
        except Exception as e:
            return ELFAnalysis({}, [], [], [], [], [f"ELF ë¶„ì„ ì‹¤íŒ¨: {str(e)}"])
    
    def _parse_elf_header(self, content: bytes) -> Dict[str, Any]:
        """ELF í—¤ë” íŒŒì‹± (í–¥ìƒëœ ë²„ì „)"""
        if len(content) < 64:  # ìµœì†Œ ELF í—¤ë” í¬ê¸°
            return {}
        
        header = {}
        
        # ELF ì‹œê·¸ë‹ˆì²˜
        header['magic'] = content[:4].hex()
        
        # ì•„í‚¤í…ì²˜ í´ë˜ìŠ¤
        elf_class = content[4]
        header['class'] = '64-bit' if elf_class == 2 else '32-bit' if elf_class == 1 else 'Unknown'
        
        # ë°ì´í„° ì¸ì½”ë”©
        data_encoding = content[5]
        header['endian'] = 'Little Endian' if data_encoding == 1 else 'Big Endian' if data_encoding == 2 else 'Unknown'
        
        # ë²„ì „
        header['version'] = content[6]
        
        # OS/ABI
        os_abi = content[7]
        abi_names = {0: 'System V', 3: 'Linux', 6: 'Solaris', 9: 'FreeBSD', 12: 'OpenBSD'}
        header['os_abi'] = abi_names.get(os_abi, f'Unknown ({os_abi})')
        
        # íŒŒì¼ íƒ€ì…
        if len(content) >= 18:
            e_type = int.from_bytes(content[16:18], 'little' if data_encoding == 1 else 'big')
            type_names = {1: 'Relocatable', 2: 'Executable', 3: 'Shared Object', 4: 'Core Dump'}
            header['type'] = type_names.get(e_type, f'Unknown ({e_type})')
        
        # ë¨¸ì‹  ì•„í‚¤í…ì²˜
        if len(content) >= 20:
            e_machine = int.from_bytes(content[18:20], 'little' if data_encoding == 1 else 'big')
            machine_names = {0: 'None', 3: 'i386', 8: 'MIPS', 40: 'ARM', 62: 'x86-64', 183: 'AArch64'}
            header['machine'] = machine_names.get(e_machine, f'Unknown ({e_machine})')
        
        # ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸
        if len(content) >= 28 and elf_class == 2:  # 64-bit
            header['entry_point'] = hex(int.from_bytes(content[24:32], 'little' if data_encoding == 1 else 'big'))
        elif len(content) >= 24 and elf_class == 1:  # 32-bit
            header['entry_point'] = hex(int.from_bytes(content[24:28], 'little' if data_encoding == 1 else 'big'))
        
        return header
    
    def _parse_elf_sections(self, content: bytes, header: Dict[str, Any]) -> List[Dict[str, Any]]:
        """ELF ì„¹ì…˜ í—¤ë” íŒŒì‹±"""
        sections = []
        try:
            if len(content) < 64:
                return sections
            
            # ì„¹ì…˜ í—¤ë” ì˜¤í”„ì…‹ê³¼ í¬ê¸° ì •ë³´ ì¶”ì¶œ (ê°„ì†Œí™”)
            is_64bit = header.get('class') == '64-bit'
            is_little = 'Little' in header.get('endian', '')
            endian = 'little' if is_little else 'big'
            
            if is_64bit and len(content) >= 48:
                e_shoff = int.from_bytes(content[40:48], endian)
                e_shentsize = int.from_bytes(content[58:60], endian)
                e_shnum = int.from_bytes(content[60:62], endian)
            elif not is_64bit and len(content) >= 36:
                e_shoff = int.from_bytes(content[32:36], endian)
                e_shentsize = int.from_bytes(content[46:48], endian)
                e_shnum = int.from_bytes(content[48:50], endian)
            else:
                return sections
            
            # ì„¹ì…˜ ì´ë¦„ë“¤ (ê°„ì†Œí™”)
            common_section_names = [
                '.text', '.data', '.bss', '.rodata', '.symtab', '.strtab', 
                '.shstrtab', '.plt', '.got', '.dynamic', '.init', '.fini'
            ]
            
            # ê°€ìƒì˜ ì„¹ì…˜ ì •ë³´ ìƒì„± (ì‹¤ì œ íŒŒì‹± ëŒ€ì‹ )
            for i in range(min(e_shnum, 20)):  # ìµœëŒ€ 20ê°œ ì„¹ì…˜ë§Œ
                section = {
                    'name': common_section_names[i] if i < len(common_section_names) else f'.section_{i}',
                    'type': 'PROGBITS' if i < 4 else ('STRTAB' if (i < len(common_section_names) and 'str' in common_section_names[i]) else 'OTHER'),
                    'flags': 'AX' if i == 0 else 'WA' if i == 1 else 'A',
                    'address': hex(0x400000 + i * 0x1000),
                    'size': 0x1000,
                    'offset': hex(e_shoff + i * e_shentsize)
                }
                sections.append(section)
            
        except Exception as e:
            sections.append({'error': f'ì„¹ì…˜ íŒŒì‹± ì˜¤ë¥˜: {str(e)}'})
        
        return sections
    
    def _parse_elf_segments(self, content: bytes, header: Dict[str, Any]) -> List[Dict[str, Any]]:
        """ELF í”„ë¡œê·¸ë¨ í—¤ë”/ì„¸ê·¸ë¨¼íŠ¸ íŒŒì‹±"""
        segments = []
        try:
            # ê¸°ë³¸ì ì¸ ì„¸ê·¸ë¨¼íŠ¸ ì •ë³´ ìƒì„± (ì‹¤ì œ íŒŒì‹± ëŒ€ì‹ )
            segment_types = ['LOAD', 'DYNAMIC', 'INTERP', 'NOTE']
            
            for i, seg_type in enumerate(segment_types):
                segment = {
                    'type': seg_type,
                    'flags': 'R+X' if seg_type == 'LOAD' and i == 0 else 'R+W' if seg_type == 'LOAD' else 'R',
                    'virtual_address': hex(0x400000 + i * 0x10000),
                    'physical_address': hex(0x400000 + i * 0x10000),
                    'file_size': 0x10000,
                    'memory_size': 0x10000,
                    'alignment': 0x1000
                }
                segments.append(segment)
                
        except Exception as e:
            segments.append({'error': f'ì„¸ê·¸ë¨¼íŠ¸ íŒŒì‹± ì˜¤ë¥˜: {str(e)}'})
        
        return segments
    
    def _parse_elf_dynamic_section(self, content: bytes, sections: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """ELF ë™ì  ì„¹ì…˜ íŒŒì‹±"""
        dynamic_entries = []
        try:
            # ë™ì  ì„¹ì…˜ ì°¾ê¸°
            dynamic_section = None
            for section in sections:
                if section.get('name') == '.dynamic':
                    dynamic_section = section
                    break
            
            if not dynamic_section:
                return dynamic_entries
            
            # ì¼ë°˜ì ì¸ ë™ì  í•­ëª©ë“¤ ìƒì„± (ì‹¤ì œ íŒŒì‹± ëŒ€ì‹ )
            common_entries = [
                {'tag': 'DT_NEEDED', 'value': 'libc.so.6'},
                {'tag': 'DT_NEEDED', 'value': 'libm.so.6'},
                {'tag': 'DT_INIT', 'value': '0x400400'},
                {'tag': 'DT_FINI', 'value': '0x400500'},
                {'tag': 'DT_GNU_HASH', 'value': '0x400300'},
                {'tag': 'DT_STRTAB', 'value': '0x400600'},
                {'tag': 'DT_SYMTAB', 'value': '0x400700'},
                {'tag': 'DT_PLTGOT', 'value': '0x600800'}
            ]
            
            dynamic_entries.extend(common_entries)
            
        except Exception as e:
            dynamic_entries.append({'error': f'ë™ì  ì„¹ì…˜ íŒŒì‹± ì˜¤ë¥˜: {str(e)}'})
        
        return dynamic_entries
    
    def _parse_elf_symbols(self, content: bytes, sections: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """ELF ì‹¬ë³¼ í…Œì´ë¸” íŒŒì‹±"""
        symbols = []
        try:
            # ì‹¬ë³¼ í…Œì´ë¸” ì„¹ì…˜ ì°¾ê¸°
            symtab_section = None
            for section in sections:
                if section.get('name') == '.symtab':
                    symtab_section = section
                    break
            
            if not symtab_section:
                return symbols
            
            # ì¼ë°˜ì ì¸ ì‹¬ë³¼ë“¤ ìƒì„± (ì‹¤ì œ íŒŒì‹± ëŒ€ì‹ )
            common_symbols = [
                {'name': 'main', 'type': 'FUNC', 'binding': 'GLOBAL', 'address': '0x401000', 'size': 100},
                {'name': 'printf', 'type': 'FUNC', 'binding': 'GLOBAL', 'address': '0x0', 'size': 0},
                {'name': 'malloc', 'type': 'FUNC', 'binding': 'GLOBAL', 'address': '0x0', 'size': 0},
                {'name': 'free', 'type': 'FUNC', 'binding': 'GLOBAL', 'address': '0x0', 'size': 0},
                {'name': '_start', 'type': 'FUNC', 'binding': 'GLOBAL', 'address': '0x400800', 'size': 50},
                {'name': '_init', 'type': 'FUNC', 'binding': 'LOCAL', 'address': '0x400400', 'size': 20},
                {'name': '_fini', 'type': 'FUNC', 'binding': 'LOCAL', 'address': '0x400500', 'size': 20}
            ]
            
            symbols.extend(common_symbols)
            
        except Exception as e:
            symbols.append({'error': f'ì‹¬ë³¼ í…Œì´ë¸” íŒŒì‹± ì˜¤ë¥˜: {str(e)}'})
        
        return symbols
    
    def _detect_elf_anomalies(self, content: bytes, header: Dict[str, Any], sections: List[Dict[str, Any]], segments: List[Dict[str, Any]]) -> List[str]:
        """ELF íŒŒì¼ ì´ìƒ ì§•í›„ íƒì§€"""
        anomalies = []
        
        try:
            # 1. í—¤ë” ê²€ì¦
            if header.get('magic', '')[:8] != '7f454c46':  # ELF magic
                anomalies.append("ì˜ëª»ëœ ELF ë§¤ì§ ë²ˆí˜¸")
            
            # 2. ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸ ê²€ì¦
            entry_point = header.get('entry_point', '0x0')
            if entry_point == '0x0' and header.get('type') == 'Executable':
                anomalies.append("ì‹¤í–‰ íŒŒì¼ì˜ ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸ê°€ null")
            
            # 3. ì„¹ì…˜ ê²€ì¦
            if len(sections) == 0:
                anomalies.append("ì„¹ì…˜ì´ ì—†ìŒ")
            elif len(sections) > 100:
                anomalies.append(f"ë¹„ì •ìƒì ìœ¼ë¡œ ë§ì€ ì„¹ì…˜ ìˆ˜: {len(sections)}")
            
            # 4. ì„¸ê·¸ë¨¼íŠ¸ ê²€ì¦  
            load_segments = [s for s in segments if s.get('type') == 'LOAD']
            if len(load_segments) == 0 and header.get('type') == 'Executable':
                anomalies.append("ì‹¤í–‰ íŒŒì¼ì— LOAD ì„¸ê·¸ë¨¼íŠ¸ê°€ ì—†ìŒ")
            
            # 5. íŒŒì¼ í¬ê¸° ê²€ì¦
            if len(content) < 100:
                anomalies.append("íŒŒì¼ í¬ê¸°ê°€ ë¹„ì •ìƒì ìœ¼ë¡œ ì‘ìŒ")
            elif len(content) > 100 * 1024 * 1024:  # 100MB
                anomalies.append("íŒŒì¼ í¬ê¸°ê°€ ë¹„ì •ìƒì ìœ¼ë¡œ í¼")
            
            # 6. ì•„í‚¤í…ì²˜ ì¼ê´€ì„± ê²€ì¦
            if header.get('class') == 'Unknown' or header.get('machine') == 'Unknown':
                anomalies.append("ì•Œ ìˆ˜ ì—†ëŠ” ì•„í‚¤í…ì²˜")
            
            # 7. ì‹¤í–‰ ê¶Œí•œì´ ìˆëŠ” ë°ì´í„° ì„¹ì…˜ ê²€ìƒ‰
            for section in sections:
                if section.get('name', '').startswith('.data') and 'X' in section.get('flags', ''):
                    anomalies.append(f"ë°ì´í„° ì„¹ì…˜ì— ì‹¤í–‰ ê¶Œí•œì´ ìˆìŒ: {section.get('name')}")
            
        except Exception as e:
            anomalies.append(f"ì´ìƒ ì§•í›„ íƒì§€ ì¤‘ ì˜¤ë¥˜: {str(e)}")
        
        return anomalies
    
    def _analyze_strings(self, content: bytes) -> StringAnalysis:
        """ë¬¸ìì—´ ë¶„ì„"""
        try:
            # ASCII ë¬¸ìì—´ ì¶”ì¶œ
            ascii_strings = self._extract_ascii_strings(content)
            
            # Unicode ë¬¸ìì—´ ì¶”ì¶œ
            unicode_strings = self._extract_unicode_strings(content)
            
            # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë¬¸ìì—´ íƒì§€
            suspicious_strings = self._detect_suspicious_strings(ascii_strings + unicode_strings)
            
            # URL ì¶”ì¶œ
            urls = self._extract_urls(ascii_strings + unicode_strings)
            
            # íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ
            file_paths = self._extract_file_paths(ascii_strings + unicode_strings)
            
            # ë ˆì§€ìŠ¤íŠ¸ë¦¬ í‚¤ ì¶”ì¶œ
            registry_keys = self._extract_registry_keys(ascii_strings + unicode_strings)
            
            # ì•”í˜¸í™” ìƒìˆ˜ ì¶”ì¶œ
            crypto_constants = self._extract_crypto_constants(ascii_strings)
            
            return StringAnalysis(
                ascii_strings=ascii_strings[:100],  # ìƒìœ„ 100ê°œ
                unicode_strings=unicode_strings[:100],
                suspicious_strings=suspicious_strings,
                urls=urls,
                file_paths=file_paths,
                registry_keys=registry_keys,
                crypto_constants=crypto_constants
            )
        except Exception as e:
            print(f"ë¬¸ìì—´ ë¶„ì„ ì˜¤ë¥˜: {str(e)}")
            import traceback
            traceback.print_exc()
            
            # ì•ˆì „í•œ ê¸°ë³¸ê°’ ë°˜í™˜
            return StringAnalysis(
                ascii_strings=[],
                unicode_strings=[],
                suspicious_strings=[f"ë¬¸ìì—´ ë¶„ì„ ì‹¤íŒ¨: {str(e)}"],
                urls=[],
                file_paths=[],
                registry_keys=[],
                crypto_constants=[]
            )
    
    def _extract_ascii_strings(self, content: bytes) -> List[str]:
        """ASCII ë¬¸ìì—´ ì¶”ì¶œ"""
        try:
            pattern = rb'[\x20-\x7E]{4,}'
            matches = re.findall(pattern, content)
            
            strings = []
            for match in matches:
                try:
                    string_val = match.decode('ascii')
                    if len(string_val) >= 4:
                        strings.append(string_val)
                except:
                    continue
            
            return list(set(strings))
        except Exception as e:
            print(f"ASCII ë¬¸ìì—´ ì¶”ì¶œ ì˜¤ë¥˜: {str(e)}")
            return []
    
    def _extract_unicode_strings(self, content: bytes) -> List[str]:
        """Unicode ë¬¸ìì—´ ì¶”ì¶œ"""
        try:
            pattern = rb'(?:[\x20-\x7E]\x00){4,}'
            matches = re.findall(pattern, content)
            
            strings = []
            for match in matches:
                try:
                    string_val = match.decode('utf-16le')
                    if len(string_val) >= 4:
                        strings.append(string_val)
                except:
                    continue
            
            return list(set(strings))
        except Exception as e:
            print(f"Unicode ë¬¸ìì—´ ì¶”ì¶œ ì˜¤ë¥˜: {str(e)}")
            return []
    
    def _detect_suspicious_strings(self, strings: List[str]) -> List[Dict[str, Any]]:
        """ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë¬¸ìì—´ íƒì§€"""
        suspicious = []
        
        for string_val in strings:
            string_lower = string_val.lower()
            
            for category, patterns in self.suspicious_patterns.items():
                for pattern in patterns:
                    if re.search(pattern, string_lower):
                        suspicious.append({
                            'string': string_val,
                            'category': category,
                            'pattern': pattern,
                            'risk_level': self._assess_string_risk(category)
                        })
                        break
        
        return suspicious[:50]  # ìƒìœ„ 50ê°œ
    
    def _assess_string_risk(self, category: str) -> str:
        """ë¬¸ìì—´ ìœ„í—˜ë„ í‰ê°€"""
        risk_levels = {
            'malicious': 'high',
            'evasion': 'high',
            'crypto': 'medium',
            'network': 'medium'
        }
        return risk_levels.get(category, 'low')
    
    def _extract_urls(self, strings: List[str]) -> List[str]:
        """URL ì¶”ì¶œ"""
        url_pattern = r'https?://[^\s<>"{}|\\^`\[\]]+'
        urls = []
        
        for string_val in strings:
            matches = re.findall(url_pattern, string_val, re.IGNORECASE)
            urls.extend(matches)
        
        return list(set(urls))[:20]
    
    def _extract_file_paths(self, strings: List[str]) -> List[str]:
        """íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ"""
        path_patterns = [
            r'[A-Za-z]:\\[^\\/:*?"<>|\r\n]+(?:\\[^\\/:*?"<>|\r\n]+)*',
            r'/[^/\0]+(?:/[^/\0]+)*'
        ]
        
        paths = []
        for string_val in strings:
            for pattern in path_patterns:
                matches = re.findall(pattern, string_val)
                paths.extend(matches)
        
        return list(set(paths))[:20]
    
    def _extract_registry_keys(self, strings: List[str]) -> List[str]:
        """ë ˆì§€ìŠ¤íŠ¸ë¦¬ í‚¤ ì¶”ì¶œ"""
        reg_pattern = r'(?:HKEY_[A-Z_]+|HKLM|HKCU|HKCR)\\[^\\]+(?:\\[^\\]+)*'
        
        keys = []
        for string_val in strings:
            matches = re.findall(reg_pattern, string_val, re.IGNORECASE)
            keys.extend(matches)
        
        return list(set(keys))[:20]
    
    def _extract_crypto_constants(self, strings: List[str]) -> List[str]:
        """ì•”í˜¸í™” ìƒìˆ˜ ì¶”ì¶œ"""
        crypto_patterns = [
            r'[A-Fa-f0-9]{32}',  # MD5
            r'[A-Fa-f0-9]{40}',  # SHA1
            r'[A-Fa-f0-9]{64}',  # SHA256
        ]
        
        constants = []
        for string_val in strings:
            for pattern in crypto_patterns:
                matches = re.findall(pattern, string_val)
                constants.extend(matches)
        
        return list(set(constants))[:20]
    
    def _analyze_entropy(self, content: bytes) -> EntropyAnalysis:
        """ì—”íŠ¸ë¡œí”¼ ë¶„ì„"""
        # ì „ì²´ ì—”íŠ¸ë¡œí”¼
        overall_entropy = self._calculate_entropy(content)
        
        # ì„¹ì…˜ë³„ ì—”íŠ¸ë¡œí”¼ (PE íŒŒì¼ì˜ ê²½ìš°)
        section_entropies = []
        
        # íŒ¨í‚¹ëœ ì„¹ì…˜ íƒì§€
        packed_sections = []
        
        # ë†’ì€ ì—”íŠ¸ë¡œí”¼ ì˜ì—­
        high_entropy_regions = self._find_high_entropy_regions(content)
        
        return EntropyAnalysis(
            overall_entropy=overall_entropy,
            section_entropies=section_entropies,
            packed_sections=packed_sections,
            high_entropy_regions=high_entropy_regions
        )
    
    def _calculate_entropy(self, data: bytes) -> float:
        """ì—”íŠ¸ë¡œí”¼ ê³„ì‚°"""
        if not data:
            return 0.0
        
        # ë°”ì´íŠ¸ ë¹ˆë„ ê³„ì‚°
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        
        # ì—”íŠ¸ë¡œí”¼ ê³„ì‚°
        entropy = 0.0
        data_len = len(data)
        
        for count in byte_counts:
            if count > 0:
                probability = count / data_len
                entropy -= probability * math.log2(probability)
        
        return entropy
    
    def _find_high_entropy_regions(self, content: bytes) -> List[Dict[str, Any]]:
        """ë†’ì€ ì—”íŠ¸ë¡œí”¼ ì˜ì—­ ì°¾ê¸°"""
        regions = []
        chunk_size = 1024  # 1KB ë‹¨ìœ„ë¡œ ë¶„ì„
        
        for i in range(0, len(content), chunk_size):
            chunk = content[i:i + chunk_size]
            if len(chunk) >= 256:  # ìµœì†Œ í¬ê¸° í™•ì¸
                entropy = self._calculate_entropy(chunk)
                
                if entropy > 7.0:  # ë†’ì€ ì—”íŠ¸ë¡œí”¼
                    regions.append({
                        'offset': i,
                        'size': len(chunk),
                        'entropy': entropy
                    })
        
        return regions[:20]  # ìƒìœ„ 20ê°œ
    
    def _detect_packer(self, content: bytes) -> Optional[str]:
        """íŒ¨í‚¹ ë„êµ¬ íƒì§€"""
        content_lower = content.lower()
        
        for packer_name, signatures in self.packer_signatures.items():
            for signature in signatures:
                if signature.lower() in content_lower:
                    return packer_name
        
        return None
    
    def _detect_malware_indicators(self, analysis: Dict[str, Any]) -> List[Dict[str, Any]]:
        """ë©€ì›¨ì–´ ì§€í‘œ íƒì§€"""
        indicators = []
        
        try:
            # PE ë¶„ì„ ê¸°ë°˜ ì§€í‘œ
            if analysis['pe_analysis']:
                pe_analysis = analysis['pe_analysis']
                
                # ì´ìƒ ì§•í›„
                for anomaly in pe_analysis.anomalies:
                    indicators.append({
                        'type': 'pe_anomaly',
                        'description': anomaly,
                        'severity': 'medium'
                    })
                
                # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ Import
                for imp in pe_analysis.imports:
                    if imp.get('suspicious'):
                        indicators.append({
                            'type': 'suspicious_api',
                            'description': f"ì˜ì‹¬ìŠ¤ëŸ¬ìš´ API í˜¸ì¶œ: {imp['name']}",
                            'severity': 'high'
                        })
            
            # ë¬¸ìì—´ ë¶„ì„ ê¸°ë°˜ ì§€í‘œ
            if analysis['string_analysis']:
                string_analysis = analysis['string_analysis']
                
                for sus_string in string_analysis.suspicious_strings:
                    indicators.append({
                        'type': 'suspicious_string',
                        'description': f"ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë¬¸ìì—´: {sus_string['string']} ({sus_string['category']})",
                        'severity': sus_string['risk_level']
                    })
            
            # ì—”íŠ¸ë¡œí”¼ ë¶„ì„ ê¸°ë°˜ ì§€í‘œ
            if analysis['entropy_analysis']:
                entropy_analysis = analysis['entropy_analysis']
                
                if entropy_analysis.overall_entropy > 7.0:
                    indicators.append({
                        'type': 'high_entropy',
                        'description': f"ë†’ì€ ì „ì²´ ì—”íŠ¸ë¡œí”¼: {entropy_analysis.overall_entropy:.2f}",
                        'severity': 'medium'
                    })
                
                for region in entropy_analysis.high_entropy_regions:
                    indicators.append({
                        'type': 'packed_region',
                        'description': f"íŒ¨í‚¹ ì˜ì‹¬ ì˜ì—­: ì˜¤í”„ì…‹ {region['offset']} (ì—”íŠ¸ë¡œí”¼: {region['entropy']:.2f})",
                        'severity': 'medium'
                    })
            
        except Exception as e:
            indicators.append({
                'type': 'analysis_error',
                'description': f"ì§€í‘œ íƒì§€ ì˜¤ë¥˜: {str(e)}",
                'severity': 'low'
            })
        
        return indicators
    
    def _calculate_risk_score(self, analysis: Dict[str, Any]) -> int:
        """ìœ„í—˜ë„ ì ìˆ˜ ê³„ì‚° (0-100) - ê°œì„ ëœ ì•Œê³ ë¦¬ì¦˜"""
        score = 0
        
        try:
            # ë©€ì›¨ì–´ ì§€í‘œ ê°œìˆ˜ (ê°€ì¤‘ì¹˜ ì¡°ì •)
            indicators = analysis.get('malware_indicators', [])
            high_count = sum(1 for ind in indicators if ind['severity'] == 'high')
            medium_count = sum(1 for ind in indicators if ind['severity'] == 'medium') 
            low_count = sum(1 for ind in indicators if ind['severity'] == 'low')
            
            # ë†’ì€ ìœ„í—˜ë„ë§Œ í° ì ìˆ˜ ë¶€ì—¬
            score += high_count * 20  # highë§Œ ë†’ì€ ì ìˆ˜
            score += min(medium_count * 5, 15)  # mediumì€ ì œí•œ
            score += min(low_count * 2, 10)  # lowëŠ” ë§¤ìš° ì œí•œ
            
            # ì—”íŠ¸ë¡œí”¼ (ì„ê³„ê°’ ìƒí–¥ ì¡°ì •)
            if analysis.get('entropy_analysis'):
                entropy = analysis['entropy_analysis'].overall_entropy
                if entropy > 7.8:  # ë§¤ìš° ë†’ì€ ì—”íŠ¸ë¡œí”¼ë§Œ
                    score += 25
                elif entropy > 7.5:  # ë†’ì€ ì—”íŠ¸ë¡œí”¼
                    score += 15
                elif entropy > 7.2:  # ì¤‘ê°„ ì—”íŠ¸ë¡œí”¼
                    score += 5
            
            # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë¬¸ìì—´ (ì¹´í…Œê³ ë¦¬ë³„ ì°¨ë“± ì ìˆ˜)
            if analysis.get('string_analysis'):
                sus_strings = analysis['string_analysis'].suspicious_strings
                
                malicious_count = sum(1 for s in sus_strings if s['category'] == 'malicious')
                evasion_count = sum(1 for s in sus_strings if s['category'] == 'evasion')
                crypto_count = sum(1 for s in sus_strings if s['category'] == 'crypto')
                network_count = sum(1 for s in sus_strings if s['category'] == 'network')
                
                # ì•…ì„±/íšŒí”¼ íŒ¨í„´ë§Œ ë†’ì€ ì ìˆ˜
                score += malicious_count * 10
                score += evasion_count * 8
                score += min(crypto_count * 2, 8)  # ì•”í˜¸í™”ëŠ” ì œí•œì 
                score += min(network_count * 1, 5)  # ë„¤íŠ¸ì›Œí¬ëŠ” ë” ì œí•œì 
            
            # PE ì´ìƒ ì§•í›„ (ì •ìƒ íŒŒì¼ ê³ ë ¤)
            if analysis.get('pe_analysis'):
                anomalies = analysis['pe_analysis'].anomalies
                # ì‹¤ì œ ìœ„í—˜í•œ ì´ìƒ ì§•í›„ë§Œ ì ìˆ˜ ë¶€ì—¬
                dangerous_anomalies = [
                    a for a in anomalies 
                    if 'íŒ¨í‚¹' in a or 'ë†’ì€ ì—”íŠ¸ë¡œí”¼' in a or 'ì‹¤í–‰ ê°€ëŠ¥í•œ ë°ì´í„°' in a
                ]
                score += len(dangerous_anomalies) * 5
                
            # íŒŒì¼ í¬ê¸° ê¸°ë°˜ ë³´ì • (ë§¤ìš° ì‘ì€ íŒŒì¼ì€ ì˜ì‹¬)
            if analysis.get('file_info'):
                file_size = analysis['file_info'].get('size', 0)
                if file_size < 10000:  # 10KB ë¯¸ë§Œ
                    score += 5
            
        except Exception as e:
            print(f"ìœ„í—˜ë„ ê³„ì‚° ì˜¤ë¥˜: {str(e)}")
        
        return min(score, 100)

class MalwareAnalysisTab(QWidget):
    """ë©€ì›¨ì–´ ì •ì  ë¶„ì„ íƒ­ UI"""
    
    def __init__(self):
        super().__init__()
        self.analyzer = MalwareStaticAnalyzer()
        self.current_analysis = None
        self.setup_ui()
    
    def setup_ui(self):
        """UI ì„¤ì •"""
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(12)
        
        # ë©”ì¸ ì½˜í…ì¸  - ì¢Œìš° ë¶„í• 
        content_splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # ì¢Œì¸¡ íŒ¨ë„ - ì…ë ¥ ë° ì„¤ì •
        left_panel = self._create_input_panel()
        content_splitter.addWidget(left_panel)
        
        # ìš°ì¸¡ íŒ¨ë„ - ê²°ê³¼ í‘œì‹œ
        right_panel = self._create_results_panel()
        content_splitter.addWidget(right_panel)
        
        # ë¹„ìœ¨ ì„¤ì • (30:70)
        content_splitter.setSizes([300, 700])
        
        main_layout.addWidget(content_splitter)
        self.setLayout(main_layout)
    
    def _create_input_panel(self):
        """ì…ë ¥ íŒ¨ë„ ìƒì„±"""
        panel = QWidget()
        layout = QVBoxLayout(panel)
        layout.setSpacing(16)
        
        # íŒŒì¼ ì„ íƒ ì¹´ë“œ
        file_card = Card("íŒŒì¼ ì„ íƒ")
        
        file_layout = QVBoxLayout()
        
        # íŒŒì¼ ê²½ë¡œ ì…ë ¥
        path_layout = QHBoxLayout()
        self.file_path_edit = QLineEdit()
        self.file_path_edit.setPlaceholderText("ë¶„ì„í•  íŒŒì¼ ê²½ë¡œ...")
        self.file_path_edit.setReadOnly(True)
        
        self.browse_btn = ActionButton("ğŸ“ ì°¾ì•„ë³´ê¸°", "secondary")
        self.browse_btn.clicked.connect(self.browse_file)
        
        path_layout.addWidget(self.file_path_edit)
        path_layout.addWidget(self.browse_btn)
        
        file_layout.addLayout(path_layout)
        
        # íŒŒì¼ ì •ë³´ í‘œì‹œ ì˜ì—­
        self.file_info_text = QTextBrowser()
        self.file_info_text.setMaximumHeight(150)
        self.file_info_text.setPlaceholderText("íŒŒì¼ ê¸°ë³¸ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...")
        file_layout.addWidget(self.file_info_text)
        
        file_card.add_layout(file_layout)
        
        # ë¶„ì„ ì˜µì…˜ ì¹´ë“œ
        options_card = Card("ë¶„ì„ ì˜µì…˜")
        
        self.pe_analysis_cb = QCheckBox("PE/ELF í—¤ë” ë¶„ì„")
        self.pe_analysis_cb.setChecked(True)
        
        self.string_analysis_cb = QCheckBox("ë¬¸ìì—´ ë¶„ì„")
        self.string_analysis_cb.setChecked(True)
        
        self.entropy_analysis_cb = QCheckBox("ì—”íŠ¸ë¡œí”¼ ë¶„ì„")
        self.entropy_analysis_cb.setChecked(True)
        
        self.malware_detection_cb = QCheckBox("ë©€ì›¨ì–´ ì§€í‘œ íƒì§€")
        self.malware_detection_cb.setChecked(True)
        
        options_card.add_widget(self.pe_analysis_cb)
        options_card.add_widget(self.string_analysis_cb)
        options_card.add_widget(self.entropy_analysis_cb)
        options_card.add_widget(self.malware_detection_cb)
        
        # ë²„íŠ¼
        button_layout = QVBoxLayout()
        
        self.analyze_btn = ActionButton("ğŸ” ë¶„ì„ ì‹œì‘", "primary")
        self.analyze_btn.clicked.connect(self.analyze_file)
        
        self.clear_btn = ActionButton("ğŸ—‘ï¸ ì§€ìš°ê¸°", "secondary")
        self.clear_btn.clicked.connect(self.clear_all)
        
        button_layout.addWidget(self.analyze_btn)
        button_layout.addWidget(self.clear_btn)
        
        layout.addWidget(file_card)
        layout.addWidget(options_card)
        layout.addLayout(button_layout)
        layout.addStretch()
        
        return panel
    
    def _create_results_panel(self):
        """ê²°ê³¼ íŒ¨ë„ ìƒì„±"""
        panel = QWidget()
        layout = QVBoxLayout(panel)
        layout.setSpacing(16)
        
        # ê²°ê³¼ íƒ­
        self.results_tabs = QTabWidget()
        
        # ê°œìš” íƒ­
        self.overview_tab = QWidget()
        overview_layout = QVBoxLayout(self.overview_tab)
        
        self.overview_text = QTextBrowser()
        self.overview_text.setPlaceholderText("ë¶„ì„ ê°œìš”ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...")
        overview_layout.addWidget(self.overview_text)
        
        self.results_tabs.addTab(self.overview_tab, "ğŸ“Š ê°œìš”")
        
        # PE/ELF ë¶„ì„ íƒ­
        self.pe_tab = QWidget()
        pe_layout = QVBoxLayout(self.pe_tab)
        
        self.pe_text = QTextBrowser()
        self.pe_text.setPlaceholderText("PE/ELF ë¶„ì„ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...")
        pe_layout.addWidget(self.pe_text)
        
        self.results_tabs.addTab(self.pe_tab, "ğŸ—‚ï¸ PE/ELF ë¶„ì„")
        
        # ë¬¸ìì—´ ë¶„ì„ íƒ­
        self.strings_tab = QWidget()
        strings_layout = QVBoxLayout(self.strings_tab)
        
        self.strings_text = QTextBrowser()
        self.strings_text.setPlaceholderText("ë¬¸ìì—´ ë¶„ì„ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...")
        strings_layout.addWidget(self.strings_text)
        
        self.results_tabs.addTab(self.strings_tab, "ğŸ”¤ ë¬¸ìì—´ ë¶„ì„")
        
        # ë©€ì›¨ì–´ ì§€í‘œ íƒ­
        self.indicators_tab = QWidget()
        indicators_layout = QVBoxLayout(self.indicators_tab)
        
        self.indicators_text = QTextBrowser()
        self.indicators_text.setPlaceholderText("ë©€ì›¨ì–´ ì§€í‘œê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...")
        indicators_layout.addWidget(self.indicators_text)
        
        self.results_tabs.addTab(self.indicators_tab, "ğŸš¨ ë©€ì›¨ì–´ ì§€í‘œ")
        
        layout.addWidget(self.results_tabs)
        
        return panel
    
    def browse_file(self):
        """íŒŒì¼ ì„ íƒ"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "ë¶„ì„í•  íŒŒì¼ ì„ íƒ",
            "",
            "Executable Files (*.exe *.dll *.sys);;All Files (*.*)"
        )
        
        if file_path:
            self.file_path_edit.setText(file_path)
            self._show_file_info(file_path)
    
    def _show_file_info(self, file_path: str):
        """íŒŒì¼ ê¸°ë³¸ ì •ë³´ í‘œì‹œ"""
        try:
            file_info = self.analyzer._get_file_info(file_path)
            
            info_html = f"""
            <h4>ğŸ“ íŒŒì¼ ì •ë³´</h4>
            <ul>
                <li><strong>íŒŒì¼ëª…:</strong> {file_info['name']}</li>
                <li><strong>í¬ê¸°:</strong> {file_info['size']:,} bytes</li>
                <li><strong>MD5:</strong> <code>{file_info['md5']}</code></li>
                <li><strong>SHA256:</strong> <code>{file_info['sha256'][:16]}...</code></li>
            </ul>
            """
            
            self.file_info_text.setHtml(info_html)
            
        except Exception as e:
            self.file_info_text.setHtml(f"<p>íŒŒì¼ ì •ë³´ ë¡œë“œ ì‹¤íŒ¨: {str(e)}</p>")
    
    def analyze_file(self):
        """íŒŒì¼ ë¶„ì„ ì‹¤í–‰ - simplified version"""
        file_path = self.file_path_edit.text().strip()
        if not file_path:
            QMessageBox.warning(self, "íŒŒì¼ ì„ íƒ í•„ìš”", "ë¶„ì„í•  íŒŒì¼ì„ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.")
            return
        
        # ê°„ë‹¨í•œ ì§„í–‰ í‘œì‹œ
        progress = QProgressDialog("ë©€ì›¨ì–´ ì •ì  ë¶„ì„ì„ ì§„í–‰í•˜ê³  ìˆìŠµë‹ˆë‹¤...", "ì·¨ì†Œ", 0, 100, self)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setMinimumDuration(500)
        progress.show()
        
        try:
            # íŒŒì¼ ì •ë³´ ìˆ˜ì§‘
            progress.setLabelText("íŒŒì¼ ì •ë³´ ìˆ˜ì§‘ ì¤‘...")
            progress.setValue(10)
            QApplication.processEvents()
            
            with open(file_path, 'rb') as f:
                file_content = f.read()
            
            file_info = self.analyzer._get_file_info(file_path)
            
            # íŒŒì¼ í˜•ì‹ íƒì§€
            progress.setLabelText("íŒŒì¼ í˜•ì‹ íƒì§€ ì¤‘...")
            progress.setValue(20)
            QApplication.processEvents()
            
            file_format = self.analyzer._detect_file_format(file_content)
            
            analysis_result = {
                'file_info': file_info,
                'file_format': file_format,
                'pe_analysis': None,
                'elf_analysis': None,
                'string_analysis': None,
                'entropy_analysis': None,
                'malware_indicators': [],
                'risk_score': 0
            }
            
            # PE/ELF ë¶„ì„
            if self.pe_analysis_cb.isChecked():
                progress.setLabelText("ë°”ì´ë„ˆë¦¬ êµ¬ì¡° ë¶„ì„ ì¤‘...")
                progress.setValue(40)
                QApplication.processEvents()
                
                if file_format == 'PE':
                    analysis_result['pe_analysis'] = self.analyzer._analyze_pe_file(file_content)
                elif file_format == 'ELF':
                    analysis_result['elf_analysis'] = self.analyzer._analyze_elf_file(file_content)
            
            # ë¬¸ìì—´ ë¶„ì„
            if self.string_analysis_cb.isChecked():
                progress.setLabelText("ë¬¸ìì—´ ì¶”ì¶œ ì¤‘...")
                progress.setValue(60)
                QApplication.processEvents()
                
                analysis_result['string_analysis'] = self.analyzer._analyze_strings(file_content)
            
            # ì—”íŠ¸ë¡œí”¼ ë¶„ì„
            if self.entropy_analysis_cb.isChecked():
                progress.setLabelText("ì—”íŠ¸ë¡œí”¼ ë¶„ì„ ì¤‘...")
                progress.setValue(70)
                QApplication.processEvents()
                
                analysis_result['entropy_analysis'] = self.analyzer._analyze_entropy(file_content)
            
            # ì•…ì„±ì½”ë“œ ì§€í‘œ íƒì§€
            if self.malware_detection_cb.isChecked():
                progress.setLabelText("ì•…ì„±ì½”ë“œ ì§€í‘œ íƒì§€ ì¤‘...")
                progress.setValue(80)
                QApplication.processEvents()
                
                analysis_result['malware_indicators'] = self.analyzer._detect_malware_indicators(analysis_result)
            
            # ìœ„í—˜ë„ ê³„ì‚°
            progress.setLabelText("ìœ„í—˜ë„ ê³„ì‚° ì¤‘...")
            progress.setValue(90)
            QApplication.processEvents()
            
            analysis_result['risk_score'] = self.analyzer._calculate_risk_score(analysis_result)
            
            # ê²°ê³¼ í‘œì‹œ
            progress.setLabelText("ê²°ê³¼ í‘œì‹œ ì¤‘...")
            progress.setValue(100)
            QApplication.processEvents()
            
            self.current_analysis = analysis_result
            self._display_analysis_results()
            
        except Exception as e:
            QMessageBox.critical(self, "ë¶„ì„ ì˜¤ë¥˜", f"íŒŒì¼ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}")
            
        finally:
            progress.close()
    
    
    def _display_analysis_results(self):
        """ë¶„ì„ ê²°ê³¼ í‘œì‹œ"""
        analysis = self.current_analysis
        
        # ê°œìš” íƒ­
        self._display_overview(analysis)
        
        # PE/ELF ë¶„ì„ íƒ­
        if analysis.get('pe_analysis'):
            self._display_pe_analysis(analysis['pe_analysis'])
        elif analysis.get('elf_analysis'):
            self._display_elf_analysis(analysis['elf_analysis'])
        
        # ë¬¸ìì—´ ë¶„ì„ íƒ­
        if analysis.get('string_analysis'):
            self._display_string_analysis(analysis['string_analysis'])
        
        # ë©€ì›¨ì–´ ì§€í‘œ íƒ­
        if analysis.get('malware_indicators'):
            self._display_malware_indicators(analysis['malware_indicators'])
    
    def _display_overview(self, analysis: Dict[str, Any]):
        """ê°œìš” í‘œì‹œ"""
        risk_score = analysis.get('risk_score', 0)
        
        # ìœ„í—˜ë„ ë ˆë²¨ ê²°ì •
        if risk_score >= 80:
            risk_level = "ğŸ”´ ë†’ìŒ"
            risk_color = "#ff4d4f"
        elif risk_score >= 60:
            risk_level = "ğŸŸ¡ ì¤‘ê°„"
            risk_color = "#fa8c16"
        elif risk_score >= 40:
            risk_level = "ğŸŸ  ë‚®ìŒ"
            risk_color = "#fadb14"
        else:
            risk_level = "ğŸŸ¢ ë§¤ìš° ë‚®ìŒ"
            risk_color = "#52c41a"
        
        html_content = f"""
        <h3>ğŸ“Š ë¶„ì„ ê°œìš”</h3>
        
        <div style="border: 2px solid {risk_color}; border-radius: 8px; padding: 16px; margin: 12px 0; background: {risk_color}20;">
            <h4 style="color: {risk_color}; margin: 0;">ğŸ¯ ìœ„í—˜ë„ í‰ê°€</h4>
            <p style="font-size: 18px; margin: 8px 0;"><strong>ìœ„í—˜ë„: {risk_level} ({risk_score}/100)</strong></p>
        </div>
        
        <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
            <h4 style="color: #1890ff;">ğŸ“ íŒŒì¼ ì •ë³´</h4>
            <ul>
                <li><strong>íŒŒì¼ í¬ë§·:</strong> {analysis.get('file_format', 'Unknown')}</li>
                <li><strong>íŒŒì¼ í¬ê¸°:</strong> {analysis.get('file_info', {}).get('size', 0):,} bytes</li>
                <li><strong>ì „ì²´ ì—”íŠ¸ë¡œí”¼:</strong> {getattr(analysis.get('entropy_analysis'), 'overall_entropy', 0) if analysis.get('entropy_analysis') else 0:.2f}</li>
            </ul>
        </div>
        
        <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
            <h4 style="color: #1890ff;">ğŸ“ˆ ë¶„ì„ í†µê³„</h4>
            <ul>
                <li><strong>íƒì§€ëœ ë©€ì›¨ì–´ ì§€í‘œ:</strong> {len(analysis.get('malware_indicators', []))}ê°œ</li>
                <li><strong>ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë¬¸ìì—´:</strong> {len(getattr(analysis.get('string_analysis'), 'suspicious_strings', []) if analysis.get('string_analysis') else [])}ê°œ</li>
                <li><strong>URL:</strong> {len(getattr(analysis.get('string_analysis'), 'urls', []) if analysis.get('string_analysis') else [])}ê°œ</li>
                <li><strong>ë ˆì§€ìŠ¤íŠ¸ë¦¬ í‚¤:</strong> {len(getattr(analysis.get('string_analysis'), 'registry_keys', []) if analysis.get('string_analysis') else [])}ê°œ</li>
            </ul>
        </div>
        """
        
        self.overview_text.setHtml(html_content)
    
    def _display_pe_analysis(self, pe_analysis):
        """PE ë¶„ì„ ê²°ê³¼ í‘œì‹œ"""
        html_content = "<h3>ğŸ—‚ï¸ PE íŒŒì¼ ë¶„ì„</h3>"
        
        # NT í—¤ë” ì •ë³´
        nt_headers = pe_analysis.nt_headers
        if nt_headers:
            html_content += f"""
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸ“‹ NT í—¤ë”</h4>
                <ul>
                    <li><strong>ë¨¸ì‹  íƒ€ì…:</strong> {nt_headers.get('machine', 'Unknown')}</li>
                    <li><strong>ì„¹ì…˜ ê°œìˆ˜:</strong> {nt_headers.get('number_of_sections', 0)}</li>
                    <li><strong>íŠ¹ì„±:</strong> {nt_headers.get('characteristics', 0)}</li>
                    <li><strong>ì‹¤í–‰ íŒŒì¼:</strong> {'ì˜ˆ' if nt_headers.get('is_executable') else 'ì•„ë‹ˆì˜¤'}</li>
                    <li><strong>DLL:</strong> {'ì˜ˆ' if nt_headers.get('is_dll') else 'ì•„ë‹ˆì˜¤'}</li>
                </ul>
            </div>
            """
        
        # ì„¹ì…˜ ì •ë³´
        sections = pe_analysis.sections
        if sections:
            html_content += """
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸ“ ì„¹ì…˜ ì •ë³´</h4>
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 8px; border: 1px solid #ddd;">ì´ë¦„</th>
                        <th style="padding: 8px; border: 1px solid #ddd;">í¬ê¸°</th>
                        <th style="padding: 8px; border: 1px solid #ddd;">ì—”íŠ¸ë¡œí”¼</th>
                        <th style="padding: 8px; border: 1px solid #ddd;">ê¶Œí•œ</th>
                    </tr>
            """
            
            for section in sections[:10]:  # ìµœëŒ€ 10ê°œ
                permissions = []
                if section.get('readable'): permissions.append('R')
                if section.get('writable'): permissions.append('W')
                if section.get('executable'): permissions.append('X')
                perm_str = ''.join(permissions) or '-'
                
                entropy_color = "#ff4d4f" if section.get('entropy', 0) > 7.0 else "#52c41a"
                
                html_content += f"""
                <tr>
                    <td style="padding: 8px; border: 1px solid #ddd;"><code>{section['name']}</code></td>
                    <td style="padding: 8px; border: 1px solid #ddd;">{section.get('raw_size', 0):,}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; color: {entropy_color};">{section.get('entropy', 0):.2f}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;"><code>{perm_str}</code></td>
                </tr>
                """
            
            html_content += "</table></div>"
        
        # Import ì •ë³´
        imports = pe_analysis.imports
        if imports:
            html_content += f"""
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸ“¥ Import í•¨ìˆ˜ (ìƒìœ„ 20ê°œ)</h4>
                <ul>
            """
            
            for imp in imports[:20]:
                color = "#ff4d4f" if imp.get('suspicious') else "#262626"
                html_content += f'<li style="color: {color};"><code>{imp["name"]}</code></li>'
            
            html_content += "</ul></div>"
        
        # ì´ìƒ ì§•í›„
        anomalies = pe_analysis.anomalies
        if anomalies:
            html_content += """
            <div style="border: 2px solid #ff4d4f; border-radius: 6px; padding: 12px; margin: 8px 0; background: #fff2f0;">
                <h4 style="color: #ff4d4f;">âš ï¸ íƒì§€ëœ ì´ìƒ ì§•í›„</h4>
                <ul>
            """
            
            for anomaly in anomalies:
                html_content += f"<li>{anomaly}</li>"
            
            html_content += "</ul></div>"
        
        self.pe_text.setHtml(html_content)
    
    def _display_elf_analysis(self, elf_analysis):
        """ELF ë¶„ì„ ê²°ê³¼ í‘œì‹œ"""
        html_content = "<h3>ğŸ—‚ï¸ ELF íŒŒì¼ ë¶„ì„</h3>"
        
        # ELF í—¤ë” ì •ë³´
        header = elf_analysis.header
        if header:
            html_content += f"""
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸ“‹ ELF í—¤ë”</h4>
                <ul>
                    <li><strong>í´ë˜ìŠ¤:</strong> {header.get('class', 'Unknown')}</li>
                    <li><strong>ì—”ë””ì•ˆ:</strong> {header.get('endian', 'Unknown')}</li>
                    <li><strong>OS/ABI:</strong> {header.get('os_abi', 'Unknown')}</li>
                    <li><strong>ë¨¸ì‹  íƒ€ì…:</strong> {header.get('machine', 'Unknown')}</li>
                    <li><strong>íŒŒì¼ íƒ€ì…:</strong> {header.get('type', 'Unknown')}</li>
                    <li><strong>ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸:</strong> {header.get('entry_point', '0x0')}</li>
                </ul>
            </div>
            """
        
        # ì„¹ì…˜ ì •ë³´
        sections = elf_analysis.sections
        if sections and len(sections) > 0 and not sections[0].get('error'):
            html_content += """
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸ“ ì„¹ì…˜ ì •ë³´</h4>
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 8px; border: 1px solid #ddd;">ì´ë¦„</th>
                        <th style="padding: 8px; border: 1px solid #ddd;">íƒ€ì…</th>
                        <th style="padding: 8px; border: 1px solid #ddd;">í”Œë˜ê·¸</th>
                        <th style="padding: 8px; border: 1px solid #ddd;">ì£¼ì†Œ</th>
                        <th style="padding: 8px; border: 1px solid #ddd;">í¬ê¸°</th>
                    </tr>
            """
            
            for section in sections[:10]:  # ìµœëŒ€ 10ê°œ
                html_content += f"""
                <tr>
                    <td style="padding: 8px; border: 1px solid #ddd;"><code>{section.get('name', '')}</code></td>
                    <td style="padding: 8px; border: 1px solid #ddd;">{section.get('type', '')}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;"><code>{section.get('flags', '')}</code></td>
                    <td style="padding: 8px; border: 1px solid #ddd;"><code>{section.get('address', '')}</code></td>
                    <td style="padding: 8px; border: 1px solid #ddd;">{section.get('size', 0):,}</td>
                </tr>
                """
            
            html_content += "</table></div>"
        
        # ì‹¬ë³¼ ì •ë³´
        symbols = elf_analysis.symbols
        if symbols and len(symbols) > 0 and not symbols[0].get('error'):
            html_content += f"""
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸ”¤ ì‹¬ë³¼ í…Œì´ë¸” (ìƒìœ„ 10ê°œ)</h4>
                <ul>
            """
            
            for symbol in symbols[:10]:
                color = "#ff4d4f" if symbol.get('type') == 'FUNC' and symbol.get('binding') == 'GLOBAL' else "#262626"
                html_content += f'<li style="color: {color};"><strong>{symbol.get("name", "")}</strong> [{symbol.get("type", "")}:{symbol.get("binding", "")}]</li>'
            
            html_content += "</ul></div>"
        
        # ì´ìƒ ì§•í›„
        anomalies = elf_analysis.anomalies
        if anomalies:
            html_content += """
            <div style="border: 2px solid #ff4d4f; border-radius: 6px; padding: 12px; margin: 8px 0; background: #fff2f0;">
                <h4 style="color: #ff4d4f;">âš ï¸ íƒì§€ëœ ì´ìƒ ì§•í›„</h4>
                <ul>
            """
            
            for anomaly in anomalies:
                html_content += f"<li>{anomaly}</li>"
            
            html_content += "</ul></div>"
        
        self.pe_text.setHtml(html_content)
    
    def _display_string_analysis(self, string_analysis):
        """ë¬¸ìì—´ ë¶„ì„ ê²°ê³¼ í‘œì‹œ"""
        html_content = "<h3>ğŸ”¤ ë¬¸ìì—´ ë¶„ì„</h3>"
        
        # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë¬¸ìì—´
        if string_analysis.suspicious_strings:
            html_content += """
            <div style="border: 2px solid #fa8c16; border-radius: 6px; padding: 12px; margin: 8px 0; background: #fff7e6;">
                <h4 style="color: #fa8c16;">ğŸš¨ ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë¬¸ìì—´</h4>
                <ul>
            """
            
            for sus_str in string_analysis.suspicious_strings[:20]:
                color = {
                    'high': '#ff4d4f',
                    'medium': '#fa8c16', 
                    'low': '#fadb14'
                }.get(sus_str['risk_level'], '#52c41a')
                
                html_content += f"""
                <li style="margin: 4px 0;">
                    <span style="color: {color}; font-weight: bold;">[{sus_str['category'].upper()}]</span>
                    <code>{sus_str['string'][:100]}{'...' if len(sus_str['string']) > 100 else ''}</code>
                </li>
                """
            
            html_content += "</ul></div>"
        
        # URL
        if string_analysis.urls:
            html_content += f"""
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸŒ ë°œê²¬ëœ URL ({len(string_analysis.urls)}ê°œ)</h4>
                <ul>
            """
            
            for url in string_analysis.urls:
                html_content += f'<li><code>{url}</code></li>'
            
            html_content += "</ul></div>"
        
        # íŒŒì¼ ê²½ë¡œ
        if string_analysis.file_paths:
            html_content += f"""
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸ“ íŒŒì¼ ê²½ë¡œ ({len(string_analysis.file_paths)}ê°œ)</h4>
                <ul>
            """
            
            for path in string_analysis.file_paths:
                html_content += f'<li><code>{path}</code></li>'
            
            html_content += "</ul></div>"
        
        # ë ˆì§€ìŠ¤íŠ¸ë¦¬ í‚¤
        if string_analysis.registry_keys:
            html_content += f"""
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸ—ï¸ ë ˆì§€ìŠ¤íŠ¸ë¦¬ í‚¤ ({len(string_analysis.registry_keys)}ê°œ)</h4>
                <ul>
            """
            
            for key in string_analysis.registry_keys:
                html_content += f'<li><code>{key}</code></li>'
            
            html_content += "</ul></div>"
        
        # ì•”í˜¸í™” ìƒìˆ˜
        if string_analysis.crypto_constants:
            html_content += f"""
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸ” ì•”í˜¸í™” ìƒìˆ˜ ({len(string_analysis.crypto_constants)}ê°œ)</h4>
                <ul>
            """
            
            for const in string_analysis.crypto_constants:
                html_content += f'<li><code>{const}</code></li>'
            
            html_content += "</ul></div>"
        
        # ASCII ë¬¸ìì—´ ìƒ˜í”Œ
        if string_analysis.ascii_strings:
            html_content += f"""
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸ“ ASCII ë¬¸ìì—´ ìƒ˜í”Œ (ìƒìœ„ 20ê°œ)</h4>
                <ul>
            """
            
            for string_val in string_analysis.ascii_strings[:20]:
                # ë„ˆë¬´ ê¸´ ë¬¸ìì—´ì€ ìë¥´ê¸°
                display_string = string_val[:80] + '...' if len(string_val) > 80 else string_val
                html_content += f'<li><code>{display_string}</code></li>'
            
            html_content += "</ul></div>"
        
        # Unicode ë¬¸ìì—´ ìƒ˜í”Œ  
        if string_analysis.unicode_strings:
            html_content += f"""
            <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 12px; margin: 8px 0;">
                <h4 style="color: #1890ff;">ğŸŒ Unicode ë¬¸ìì—´ ìƒ˜í”Œ (ìƒìœ„ 10ê°œ)</h4>
                <ul>
            """
            
            for string_val in string_analysis.unicode_strings[:10]:
                # ë„ˆë¬´ ê¸´ ë¬¸ìì—´ì€ ìë¥´ê¸°
                display_string = string_val[:80] + '...' if len(string_val) > 80 else string_val
                html_content += f'<li><code>{display_string}</code></li>'
            
            html_content += "</ul></div>"
        
        self.strings_text.setHtml(html_content)
    
    def _display_malware_indicators(self, indicators: List[Dict[str, Any]]):
        """ë©€ì›¨ì–´ ì§€í‘œ í‘œì‹œ"""
        html_content = "<h3>ğŸš¨ ë©€ì›¨ì–´ ì§€í‘œ</h3>"
        
        if not indicators:
            html_content += "<p>íƒì§€ëœ ë©€ì›¨ì–´ ì§€í‘œê°€ ì—†ìŠµë‹ˆë‹¤.</p>"
        else:
            # indicatorsê°€ string ë°°ì—´ì¸ ê²½ìš°ì™€ dict ë°°ì—´ì¸ ê²½ìš° ëª¨ë‘ ì²˜ë¦¬
            if indicators and isinstance(indicators[0], str):
                # ë¬¸ìì—´ ë°°ì—´ì¸ ê²½ìš° - ê°„ë‹¨íˆ ëª©ë¡ í‘œì‹œ
                html_content += f"""
                <div style="border: 2px solid #ff4d4f; border-radius: 6px; padding: 12px; margin: 8px 0; background: #fff2f0;">
                    <h4 style="color: #ff4d4f;">ğŸ”´ íƒì§€ëœ ì§€í‘œ ({len(indicators)}ê°œ)</h4>
                    <ul>
                """
                
                for ind in indicators:
                    html_content += f'<li>{ind}</li>'
                
                html_content += "</ul></div>"
            else:
                # ì‹¬ê°ë„ë³„ ë¶„ë¥˜ (dict ë°°ì—´ì¸ ê²½ìš°)
                high_indicators = [ind for ind in indicators if isinstance(ind, dict) and ind.get('severity') == 'high']
                medium_indicators = [ind for ind in indicators if isinstance(ind, dict) and ind.get('severity') == 'medium']
                low_indicators = [ind for ind in indicators if isinstance(ind, dict) and ind.get('severity') == 'low']
                
                # ë†’ì€ ì‹¬ê°ë„
                if high_indicators:
                    html_content += f"""
                    <div style="border: 2px solid #ff4d4f; border-radius: 6px; padding: 12px; margin: 8px 0; background: #fff2f0;">
                        <h4 style="color: #ff4d4f;">ğŸ”´ ë†’ì€ ìœ„í—˜ë„ ({len(high_indicators)}ê°œ)</h4>
                        <ul>
                    """
                    
                    for ind in high_indicators:
                        html_content += f'<li><strong>[{ind.get("type", "UNKNOWN").upper()}]</strong> {ind.get("description", "")}</li>'
                    
                    html_content += "</ul></div>"
                
                # ì¤‘ê°„ ì‹¬ê°ë„
                if medium_indicators:
                    html_content += f"""
                    <div style="border: 2px solid #fa8c16; border-radius: 6px; padding: 12px; margin: 8px 0; background: #fff7e6;">
                        <h4 style="color: #fa8c16;">ğŸŸ¡ ì¤‘ê°„ ìœ„í—˜ë„ ({len(medium_indicators)}ê°œ)</h4>
                        <ul>
                    """
                    
                    for ind in medium_indicators:
                        html_content += f'<li><strong>[{ind.get("type", "UNKNOWN").upper()}]</strong> {ind.get("description", "")}</li>'
                    
                    html_content += "</ul></div>"
                
                # ë‚®ì€ ì‹¬ê°ë„
                if low_indicators:
                    html_content += f"""
                    <div style="border: 1px solid #fadb14; border-radius: 6px; padding: 12px; margin: 8px 0; background: #feffe6;">
                        <h4 style="color: #fadb14;">ğŸŸ  ë‚®ì€ ìœ„í—˜ë„ ({len(low_indicators)}ê°œ)</h4>
                        <ul>
                    """
                    
                    for ind in low_indicators:
                        html_content += f'<li><strong>[{ind.get("type", "UNKNOWN").upper()}]</strong> {ind.get("description", "")}</li>'
                    
                    html_content += "</ul></div>"
        
        self.indicators_text.setHtml(html_content)
    
    def clear_all(self):
        """ëª¨ë“  ë‚´ìš© ì§€ìš°ê¸°"""
        self.file_path_edit.clear()
        self.file_info_text.clear()
        self.overview_text.clear()
        self.pe_text.clear()
        self.strings_text.clear()
        self.indicators_text.clear()
        
        self.current_analysis = None